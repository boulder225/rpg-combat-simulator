---
phase: 05-spells-conditions-resume
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/simulation/simulator.py
  - src/simulation/monte_carlo.py
  - src/agents/heuristic.py
  - tests/test_simulator.py
autonomous: true

must_haves:
  truths:
    - "Spellcaster uses spell slot when casting a leveled spell, cannot cast when slots depleted"
    - "Casting a second concentration spell ends the first automatically"
    - "Taking damage while concentrating triggers CON save; failure ends concentration"
    - "Concentration save is NOT triggered when final_damage is 0 (immunity)"
    - "Prone target gives melee attackers advantage, ranged attackers disadvantage in attack resolution"
    - "Stunned creatures are skipped (incapacitated) and grant advantage to attackers"
    - "Fresh creature copies in Monte Carlo reset conditions and concentration"
    - "Heuristic agent checks spell slot availability before choosing AoE/spell actions"
  artifacts:
    - path: "src/simulation/simulator.py"
      provides: "Spell-slot-aware combat with concentration and condition mechanics"
      contains: "_can_cast_spell"
    - path: "src/simulation/monte_carlo.py"
      provides: "Fresh creature reset including conditions and concentration"
      contains: "conditions"
    - path: "src/agents/heuristic.py"
      provides: "Spell-slot-aware heuristic agent"
      contains: "spell_slots"
  key_links:
    - from: "src/simulation/simulator.py"
      to: "src/domain/conditions.py"
      via: "imports condition functions for attack advantage"
      pattern: "get_attacker_disadvantage_sources"
    - from: "src/simulation/simulator.py"
      to: "src/domain/rules.py"
      via: "calls make_concentration_save after damage"
      pattern: "make_concentration_save"
    - from: "src/simulation/simulator.py"
      to: "src/domain/creature.py"
      via: "checks spell_slots, updates concentration via state.update_creature"
      pattern: "spell_slots"
---

<objective>
Integrate spell slot tracking, concentration management, and condition-based advantage/disadvantage into the combat simulator. Update Monte Carlo fresh creature reset and heuristic agent for spell-slot awareness.

Purpose: Make the simulator enforce D&D 5e spell and condition rules so combat results reflect realistic spellcaster behavior. This satisfies success criteria 1-4.

Output: Spell-slot-aware simulator, condition-based advantage in attack rolls, concentration saves after damage, updated heuristic agent and Monte Carlo reset.
</objective>

<execution_context>
@/Users/enrico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enrico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-spells-conditions-resume/05-RESEARCH.md
@.planning/phases/05-spells-conditions-resume/05-01-SUMMARY.md
@.planning/phases/05-spells-conditions-resume/05-03-SUMMARY.md
@src/simulation/simulator.py
@src/simulation/monte_carlo.py
@src/agents/heuristic.py
@src/domain/conditions.py
@src/domain/rules.py
@src/domain/creature.py
@src/domain/dice.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Spell slot deduction, concentration management, and condition advantage in simulator</name>
  <files>
    src/simulation/simulator.py
    tests/test_simulator.py
  </files>
  <action>
Add three capabilities to `src/simulation/simulator.py`:

**1. Spell slot checking and deduction:**

Add helper functions at module level:

```python
def _can_cast_spell(creature, action_obj) -> bool:
    """Check if creature has spell slot for this spell level."""
    if action_obj.spell_level is None:
        return True  # cantrip or non-spell
    return creature.spell_slots.get(action_obj.spell_level, 0) > 0

def _deduct_spell_slot(state, caster_id, spell_level):
    """Deduct one spell slot. Returns new CombatState."""
    caster = state.creatures[caster_id]
    new_slots = dict(caster.spell_slots)
    new_slots[spell_level] = max(0, new_slots.get(spell_level, 0) - 1)
    return state.update_creature(caster_id, spell_slots=new_slots)
```

In `run_combat()`, before `_resolve_aoe()` call (the `if action.action_type == "aoe"` block):
- Look up the action_obj, check `_can_cast_spell(c, action_obj)`
- If can't cast (no slots), log "  {name} has no spell slots for {spell_name}! Skipping." and continue
- If can cast and `action_obj.spell_level is not None`, call `state = _deduct_spell_slot(state, cid, action_obj.spell_level)`
- If `action_obj.is_concentration`, call `state = _start_concentration(state, cid, action_obj.name, logger)`
- Then resolve AoE as before

Similarly, for the attack path: if the chosen action has `spell_level is not None`, check and deduct before resolving attacks. This covers single-target spells used via attack actions.

**2. Concentration management:**

Add helper:

```python
def _start_concentration(state, caster_id, spell_name, logger):
    """End existing concentration (if any) and start new."""
    caster = state.creatures[caster_id]
    if caster.concentration is not None:
        logger.log(f"  {caster.name}'s concentration on {caster.concentration} ends.")
        state = state.update_creature(caster_id, concentration=None)
    state = state.update_creature(caster_id, concentration=spell_name)
    logger.log(f"  {caster.name} concentrates on {spell_name}.")
    return state
```

After EVERY damage application in the simulator (there are three sites: normal attack, opportunity attack, AoE), add concentration check:

```python
if final_damage > 0:
    target_now = state.creatures[target_id]
    if target_now.concentration is not None:
        save_result = rules.make_concentration_save(target_now, final_damage)
        logger.log(f"  {target_now.name} concentration save (DC {max(10, final_damage // 2)}): {save_result.description}")
        if not save_result.is_success:
            logger.log(f"  {target_now.name} loses concentration on {target_now.concentration}!")
            state = state.update_creature(target_id, concentration=None)
```

Important: Do NOT trigger concentration save when `final_damage == 0` (immunity case).

**3. Condition-based advantage/disadvantage in attack rolls:**

Import at top of file:
```python
from src.domain.conditions import (
    get_attacker_disadvantage_sources,
    get_target_advantage_sources,
    get_target_disadvantage_sources,
)
from src.domain.dice import resolve_advantage
```

In the attack resolution loop (the `for atk in action_obj.attacks:` block), before calling `rules.make_attack_roll()`:

```python
is_melee = atk.reach is not None
adv_sources = get_target_advantage_sources(c, target, is_melee)
disadv_sources = (
    get_attacker_disadvantage_sources(c)
    + get_target_disadvantage_sources(c, target, is_melee)
)
advantage_state = resolve_advantage(adv_sources, disadv_sources) if (adv_sources or disadv_sources) else None
```

Pass `advantage_state` to `make_attack_roll` instead of `None`. Keep existing `cover_bonus` handling unchanged.

Apply the same condition-based advantage to opportunity attacks in `_resolve_opportunity_attacks()`.

**4. Skip stunned creatures:**

In `run_combat()`, after the `if c.current_hp <= 0: continue` check, add:

```python
if "stunned" in c.conditions or "paralyzed" in c.conditions:
    logger.log(f"  {c.name} is incapacitated and cannot act.")
    state = state.next_turn()
    if is_combat_over(state):
        break
    continue
```

**Tests in `tests/test_simulator.py`:**
- `test_spell_slot_deduction`: Create wizard with spell_slots={3: 2}, cast Fireball twice -> slots go to 1 then 0, third attempt skipped
- `test_concentration_ends_on_new_spell`: Cast Haste (concentration), then cast another concentration spell -> first ends
- `test_concentration_save_on_damage`: Creature concentrating takes damage -> save triggered, if fail -> concentration=None
- `test_concentration_save_not_on_zero_damage`: Immune creature takes 0 fire damage -> no concentration save
- `test_prone_advantage_melee`: Attack prone target from melee -> advantage
- `test_prone_disadvantage_ranged`: Attack prone target from range -> disadvantage
- `test_stunned_creature_skipped`: Stunned creature's turn is skipped
  </action>
  <verify>cd /Users/enrico/workspace/myobsidian/dnd-simulator && python -m pytest tests/test_simulator.py -v</verify>
  <done>Simulator enforces spell slot deduction, concentration one-at-a-time rule, concentration saves after damage, and condition-based advantage/disadvantage; stunned creatures are skipped</done>
</task>

<task type="auto">
  <name>Task 2: Monte Carlo fresh creature reset and heuristic agent spell awareness</name>
  <files>
    src/simulation/monte_carlo.py
    src/agents/heuristic.py
  </files>
  <action>
**Monte Carlo reset:**

In `MonteCarloSimulator._create_fresh_creatures()`, after `fresh_copy.current_hp = fresh_copy.hp_max`, add:

```python
fresh_copy.conditions = []
fresh_copy.concentration = None
# spell_slots: deep copy already has template values from model_copy(deep=True)
# No need to touch spell_slots — they're already fresh from the template
```

This ensures each simulation run starts clean: no lingering conditions or concentration from a previous run. The `spell_slots` are already correct because `model_copy(deep=True)` copies the template creature's original slot counts.

**Heuristic agent spell slot awareness:**

In `HeuristicAgent.choose_action()` in `src/agents/heuristic.py`:

1. In the AoE selection block (the `for act in creature.actions:` loop checking `is_aoe`), add spell slot check:

```python
# Before returning AoE action, check spell slots
if act.spell_level is not None:
    if creature.spell_slots.get(act.spell_level, 0) <= 0:
        continue  # No slots for this spell, try next action
```

This prevents the agent from trying to cast Fireball when it has no level-3 slots left.

2. In the fallback AoE block (the second `for act in creature.actions:` loop), add the same check.

3. For the attack action path: no change needed — if an attack-based action has a spell_level, the simulator handles the slot check and skip. But for clarity, add a similar check in the attack action selection if the best_action has a spell_level:

```python
# After selecting best_action, verify spell slots if needed
if best_action.spell_level is not None and creature.spell_slots.get(best_action.spell_level, 0) <= 0:
    # Fall back to actions without spell requirements
    non_spell_actions = [a for a in attack_actions if a.spell_level is None]
    if non_spell_actions:
        best_action = non_spell_actions[0]
    else:
        # No usable actions
        return AgentAction(action_type="dodge", description="No spell slots", strategy_summary="No spell slots remaining; dodge.")
```

No new test file needed — the simulator tests from Task 1 cover the integration. The agent is tested implicitly when the simulator runs with a heuristic agent on a wizard with limited spell slots.
  </action>
  <verify>cd /Users/enrico/workspace/myobsidian/dnd-simulator && python -m pytest tests/ -v</verify>
  <done>Monte Carlo resets conditions/concentration between runs; heuristic agent skips spells when slots depleted; full test suite green</done>
</task>

</tasks>

<verification>
```bash
cd /Users/enrico/workspace/myobsidian/dnd-simulator

# Run simulator tests (spell slots, concentration, conditions)
python -m pytest tests/test_simulator.py -v

# Integration: run a quick simulation with wizard to verify spell slots deplete
python run.py --party wizard.md --enemies goblin goblin goblin --seed 42

# Full test suite
python -m pytest tests/ -v
```
</verification>

<success_criteria>
- Wizard casting Fireball deducts a level-3 spell slot
- Wizard with 0 level-3 slots cannot cast Fireball (skipped, falls back)
- Casting a second concentration spell ends the first
- Damage to concentrating creature triggers CON save with DC = max(10, damage // 2)
- Zero damage (immunity) does NOT trigger concentration save
- Prone target attacked in melee -> advantage; at range -> disadvantage
- Stunned creature's turn is skipped
- Monte Carlo runs start with clean conditions/concentration
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-spells-conditions-resume/05-02-SUMMARY.md`
</output>

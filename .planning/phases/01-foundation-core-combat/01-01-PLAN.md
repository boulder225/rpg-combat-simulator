---
phase: 01-foundation-core-combat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/__init__.py
  - src/domain/__init__.py
  - src/domain/creature.py
  - src/domain/distance.py
  - src/domain/combat_state.py
  - src/io/__init__.py
  - src/io/markdown.py
  - src/agents/__init__.py
  - src/simulation/__init__.py
  - data/creatures/goblin.md
  - data/creatures/fighter.md
  - tests/__init__.py
  - tests/test_creature.py
  - tests/test_distance.py
  - tests/test_combat_state.py
  - tests/test_markdown.py
autonomous: true

must_haves:
  truths:
    - "Creature markdown files parse into validated Pydantic models with stats, actions, resistances"
    - "Chess-notation coordinates convert to (x,y) tuples and Manhattan distance calculates correctly"
    - "CombatState is immutable and copy-on-write updates produce new state objects"
    - "Initiative ordering sorts creatures by roll descending with alphabetical tiebreaker"
  artifacts:
    - path: "src/domain/creature.py"
      provides: "Creature, Action, Attack, StatBlock Pydantic models"
      exports: ["Creature", "Action", "Attack", "DamageRoll", "AbilityScores", "DeathSaves"]
    - path: "src/domain/distance.py"
      provides: "Chess notation parsing and Manhattan distance"
      exports: ["parse_coordinate", "manhattan_distance", "distance_in_feet", "to_coordinate"]
    - path: "src/domain/combat_state.py"
      provides: "Immutable combat state with initiative ordering"
      exports: ["CombatState", "roll_initiative"]
    - path: "src/io/markdown.py"
      provides: "Markdown creature file parser"
      exports: ["load_creature", "load_creatures_from_dir"]
    - path: "data/creatures/goblin.md"
      provides: "Sample enemy creature file"
    - path: "data/creatures/fighter.md"
      provides: "Sample PC creature file"
  key_links:
    - from: "src/io/markdown.py"
      to: "src/domain/creature.py"
      via: "Parses YAML frontmatter into Creature model"
      pattern: "Creature\\("
    - from: "src/domain/combat_state.py"
      to: "src/domain/creature.py"
      via: "CombatState holds dict of Creature objects"
      pattern: "dict\\[str,\\s*Creature\\]"
    - from: "src/domain/combat_state.py"
      to: "src/domain/distance.py"
      via: "Initiative and state use coordinate types"
      pattern: "parse_coordinate|manhattan_distance"
---

<objective>
Set up the project foundation: Python package structure, Pydantic creature/action models, chess-notation grid with Manhattan distance, immutable combat state, and markdown creature file parser.

Purpose: Everything in Phase 1 depends on these foundational types. Creature models define the data shape for combat rules, agents, and simulation. The grid system enables all positioning and range calculations. CombatState is the core data structure that flows through the entire simulator.

Output: Working Python package with validated creature models, grid system, combat state, markdown parser, sample creature files, and passing unit tests.
</objective>

<execution_context>
@/Users/enrico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enrico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-combat/01-RESEARCH.md
@.requirements/Combat Simulator.md
@.requirements/Recommended Project Structure.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project setup + Creature/Action Pydantic models</name>
  <files>
    pyproject.toml
    src/__init__.py
    src/domain/__init__.py
    src/domain/creature.py
    src/agents/__init__.py
    src/simulation/__init__.py
    tests/__init__.py
    tests/test_creature.py
    data/creatures/goblin.md
    data/creatures/fighter.md
  </files>
  <action>
    1. Create pyproject.toml with uv/hatch build system. Project name: dnd-combat-sim. Python >=3.11. Dependencies: d20>=1.1.2, pydantic>=2.12, python-frontmatter>=1.1.0. Dev dependencies: pytest>=8.0. Add [tool.pytest.ini_options] with testpaths = ["tests"].

    2. Create package structure: src/__init__.py, src/domain/__init__.py, src/agents/__init__.py, src/simulation/__init__.py, tests/__init__.py (all empty or with minimal exports).

    3. Create src/domain/creature.py with these Pydantic v2 models:

    - AbilityScores(BaseModel): str, dex, con, int_, wis, cha (all int, default 10). Add computed property `modifier(score)` returning `(score - 10) // 2`. Add method `get_modifier(ability: str) -> int`.

    - DeathSaves(BaseModel, frozen=True): successes: int = 0, failures: int = 0, stable: bool = False.

    - DamageRoll(BaseModel): dice: str (e.g., "1d6+3"), damage_type: str (e.g., "slashing").

    - Attack(BaseModel): name: str, attack_bonus: int, damage: DamageRoll, reach: int | None = None (in feet), range: int | None = None (in feet). Add computed property `range_feet` returning reach or range (prefer reach for melee).

    - Action(BaseModel): name: str, description: str = "", attacks: list[Attack] = [] (for Multiattack, this holds the sub-attacks). Add `is_multiattack` property returning len(attacks) > 1.

    - Creature(BaseModel): name: str, ac: int, hp_max: int, current_hp: int | None = None (default to hp_max via validator), speed: int = 30, initiative_bonus: int = 0, team: str, position: str = "A1", ability_scores: AbilityScores = AbilityScores(), actions: list[Action] = [], damage_resistances: list[str] = [], damage_immunities: list[str] = [], damage_vulnerabilities: list[str] = [], death_saves: DeathSaves = DeathSaves(), creature_id: str = "". Use model_validator to set current_hp = hp_max if None.

    Important: Use Pydantic v2 syntax (model_validator, computed_field). Do NOT use Pydantic v1 validators (@validator). Make Creature copyable via model_copy(update={...}) for immutable state pattern.

    4. Create two sample creature markdown files:

    data/creatures/goblin.md:
    ```yaml
    ---
    name: Goblin
    ac: 15
    hp_max: 7
    speed: 30
    initiative_bonus: 2
    team: enemies
    position: E5
    ability_scores:
      str: 8
      dex: 14
      con: 10
      int_: 10
      wis: 8
      cha: 8
    damage_resistances: []
    damage_immunities: []
    damage_vulnerabilities: []
    actions:
      - name: Scimitar
        attacks:
          - name: Scimitar
            attack_bonus: 4
            damage:
              dice: "1d6+2"
              damage_type: slashing
            reach: 5
      - name: Shortbow
        attacks:
          - name: Shortbow
            attack_bonus: 4
            damage:
              dice: "1d6+2"
              damage_type: piercing
            range: 80
    ---
    A nimble goblin warrior armed with a scimitar and shortbow.
    ```

    data/creatures/fighter.md:
    ```yaml
    ---
    name: Fighter
    ac: 18
    hp_max: 44
    speed: 30
    initiative_bonus: 1
    team: party
    position: B2
    ability_scores:
      str: 16
      dex: 12
      con: 14
      int_: 10
      wis: 13
      cha: 8
    damage_resistances: []
    damage_immunities: []
    damage_vulnerabilities: []
    actions:
      - name: Multiattack
        description: "Makes two longsword attacks."
        attacks:
          - name: Longsword
            attack_bonus: 5
            damage:
              dice: "1d8+3"
              damage_type: slashing
            reach: 5
          - name: Longsword
            attack_bonus: 5
            damage:
              dice: "1d8+3"
              damage_type: slashing
            reach: 5
      - name: Longsword
        attacks:
          - name: Longsword
            attack_bonus: 5
            damage:
              dice: "1d8+3"
              damage_type: slashing
            reach: 5
    ---
    A veteran fighter in plate armor wielding a longsword.
    ```

    5. Create tests/test_creature.py: Test Creature creation with all fields, test current_hp defaults to hp_max, test ability score modifiers (10 -> 0, 16 -> +3, 8 -> -1), test DeathSaves frozen, test Action.is_multiattack, test Attack.range_feet, test model_copy produces independent copy.

    6. Run `uv sync` to install dependencies, then `uv run pytest tests/test_creature.py -v` to verify.
  </action>
  <verify>
    uv run pytest tests/test_creature.py -v
    All tests pass. Creature model validates, current_hp defaults work, ability modifiers correct, model_copy works.
  </verify>
  <done>
    Pydantic creature models validate with all fields. Sample creature .md files exist. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Grid system + Combat State + Markdown parser</name>
  <files>
    src/domain/distance.py
    src/domain/combat_state.py
    src/io/__init__.py
    src/io/markdown.py
    tests/test_distance.py
    tests/test_combat_state.py
    tests/test_markdown.py
  </files>
  <action>
    1. Create src/domain/distance.py:

    - parse_coordinate(coord: str) -> tuple[int, int]: Parse chess notation (A1, C4, Z20) to (x, y) tuple. A=0, B=1, etc. Rank 1=0, 2=1, etc. Validate file is A-Z, rank is 1-99. Raise ValueError on invalid input. Handle uppercase/strip.

    - to_coordinate(x: int, y: int) -> str: Convert (x, y) back to chess notation. x=0 -> "A", y=0 -> "1".

    - manhattan_distance(pos1: str, pos2: str) -> int: Distance in grid squares between two chess-notation positions.

    - distance_in_feet(pos1: str, pos2: str) -> int: Manhattan distance * 5.

    - move_toward(from_pos: str, to_pos: str, speed_squares: int) -> str: Move from_pos toward to_pos up to speed_squares. Return new position as chess notation. Use greedy step-by-step Manhattan movement (reduce largest axis difference first).

    2. Create src/domain/combat_state.py:

    Use frozen dataclass (NOT Pydantic) for CombatState since it's an immutable value object, not a validation model.

    ```python
    from dataclasses import dataclass, replace, field

    @dataclass(frozen=True)
    class CombatState:
        creatures: dict[str, Creature]  # creature_id -> Creature
        initiative_order: list[str]     # ordered creature_ids
        current_turn: int = 0           # index into initiative_order
        round: int = 1
        combat_log: list[str] = field(default_factory=list)
        is_over: bool = False
        winner: str | None = None       # team name
    ```

    Add methods (all return new CombatState via `replace`):
    - update_creature(creature_id, **updates) -> CombatState: Update a creature's fields via model_copy.
    - add_log(message: str) -> CombatState: Append to combat_log (create new list).
    - next_turn() -> CombatState: Advance current_turn, wrap to next round.
    - end_combat(winner: str) -> CombatState: Set is_over=True, winner=team.

    Add standalone function:
    - roll_initiative(creatures: dict[str, Creature], seed: int | None = None) -> list[str]: Roll d20 + initiative_bonus for each creature. Sort descending by total, then alphabetical creature_id for ties. If seed provided, set random seed first (for d20 library, use d20.roll with manual seeding via random module). Return ordered list of creature_ids.

    NOTE: For seeded rolls in initiative, use Python's `random` module to generate pre-determined d20 values and add initiative_bonus, rather than trying to seed the d20 library (which uses its own RNG). This keeps deterministic seeding simple.

    3. Create src/io/markdown.py:

    - load_creature(filepath: Path) -> tuple[str, Creature]: Use python-frontmatter to parse .md file. Extract YAML frontmatter, validate with Creature model. The creature_id is the filename stem (e.g., "goblin" from "goblin.md"). Set creature_id on the model. Return (creature_id, Creature).

    - load_creatures_from_dir(dirpath: Path) -> dict[str, Creature]: Load all .md files from directory, return dict of creature_id -> Creature.

    - load_creature_files(filepaths: list[Path]) -> dict[str, Creature]: Load specific .md files, return dict.

    Handle errors: FileNotFoundError for missing files, ValidationError for invalid YAML/fields. Raise with clear messages including filepath.

    4. Create tests/test_distance.py: Test parse_coordinate("A1") -> (0,0), parse_coordinate("C4") -> (2,3), to_coordinate(0,0) -> "A1", manhattan_distance("A1", "C4") -> 5, distance_in_feet("A1", "A1") -> 0, move_toward basic cases, invalid coordinate raises ValueError.

    5. Create tests/test_combat_state.py: Test CombatState is frozen (cannot assign), test update_creature returns new state, test add_log appends, test next_turn wraps around, test roll_initiative ordering (mock random for determinism).

    6. Create tests/test_markdown.py: Test load_creature with goblin.md parses correctly (name, ac, hp, actions). Test creature_id is filename stem. Test missing file raises FileNotFoundError.

    7. Run all tests: `uv run pytest tests/ -v`
  </action>
  <verify>
    uv run pytest tests/ -v
    All tests pass including creature, distance, combat_state, and markdown tests.
  </verify>
  <done>
    Chess notation parses correctly. Manhattan distance calculates. CombatState is immutable with copy-on-write. Markdown parser loads creature files into validated models. All tests green.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -v` -- all tests pass
2. `uv run python -c "from src.domain.creature import Creature; print('Creature import OK')"` -- imports work
3. `uv run python -c "from src.io.markdown import load_creature; from pathlib import Path; cid, c = load_creature(Path('data/creatures/goblin.md')); print(f'{c.name}: AC {c.ac}, HP {c.hp_max}')"` -- prints "Goblin: AC 15, HP 7"
4. `uv run python -c "from src.domain.distance import manhattan_distance; print(manhattan_distance('A1', 'C4'))"` -- prints "5"
</verification>

<success_criteria>
- Creature Pydantic model validates with all required fields (name, ac, hp, speed, actions, resistances)
- Sample creature .md files parse without errors
- Chess notation A1-Z20 converts to/from (x,y) tuples
- Manhattan distance returns correct values (A1 to C4 = 5 squares)
- CombatState is frozen dataclass, all methods return new instances
- Initiative ordering works (descending total, alphabetical tiebreak)
- 15+ unit tests passing across 4 test files
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-combat/01-01-SUMMARY.md`
</output>

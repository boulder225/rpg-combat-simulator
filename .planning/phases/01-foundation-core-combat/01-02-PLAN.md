---
phase: 01-foundation-core-combat
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/domain/dice.py
  - src/domain/rules.py
  - tests/test_dice.py
  - tests/test_rules.py
autonomous: true

must_haves:
  truths:
    - "Attack rolls resolve d20 + modifier vs AC with natural 20 always hitting and natural 1 always missing"
    - "Advantage rolls 2d20 keep highest, disadvantage rolls 2d20 keep lowest, any adv + any disadv cancels to normal"
    - "Damage with resistance is halved (floor), immunity is zero, vulnerability is doubled -- strict order, no stacking"
    - "Death saves track successes/failures separately; nat 1 = 2 failures, nat 20 = regain 1 HP and reset"
    - "Saving throws resolve d20 + ability modifier vs DC"
    - "Critical hits double the damage dice (roll twice)"
    - "Healing restores HP up to hp_max, never exceeding it"
  artifacts:
    - path: "src/domain/dice.py"
      provides: "Advantage state machine, d20 rolling with advantage/disadvantage"
      exports: ["AdvantageState", "resolve_advantage", "roll_d20", "roll_damage"]
    - path: "src/domain/rules.py"
      provides: "Attack resolution, damage application, saving throws, death saves, healing"
      exports: ["make_attack_roll", "roll_damage_for_attack", "apply_damage_modifiers", "apply_damage", "make_saving_throw", "make_death_save", "apply_healing"]
  key_links:
    - from: "src/domain/rules.py"
      to: "src/domain/dice.py"
      via: "Rules use dice for all rolls"
      pattern: "roll_d20|roll_damage|AdvantageState"
    - from: "src/domain/rules.py"
      to: "src/domain/creature.py"
      via: "Rules operate on Creature models"
      pattern: "Creature|creature\\.ac|creature\\.current_hp"
---

<objective>
Implement the D&D 5e rules engine: dice rolling with advantage/disadvantage state machine, attack rolls, damage with resistance/immunity/vulnerability, saving throws, death saving throws, critical hits, and healing.

Purpose: The rules engine is the core D&D 5e mechanics layer. Every combat action flows through these functions. Correctness here determines whether the simulator produces realistic results. The advantage/disadvantage ternary state and damage modifier ordering are the most common sources of bugs in D&D simulators.

Output: Dice module with advantage state machine, rules module with all combat mechanics, comprehensive test suite proving D&D 5e correctness.
</objective>

<execution_context>
@/Users/enrico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enrico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-combat/01-RESEARCH.md
@.planning/phases/01-foundation-core-combat/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Dice engine with advantage/disadvantage state machine</name>
  <files>
    src/domain/dice.py
    tests/test_dice.py
  </files>
  <action>
    Create src/domain/dice.py:

    1. AdvantageState enum: ADVANTAGE = "advantage", NORMAL = "normal", DISADVANTAGE = "disadvantage"

    2. resolve_advantage(advantage_sources: list[str], disadvantage_sources: list[str]) -> AdvantageState:
       - If ANY advantage source AND ANY disadvantage source exist -> NORMAL (complete cancellation)
       - If only advantage sources -> ADVANTAGE
       - If only disadvantage sources -> DISADVANTAGE
       - If neither -> NORMAL
       Critical: Do NOT implement as counter subtraction. This is a ternary state machine.

    3. roll_d20(advantage: AdvantageState = AdvantageState.NORMAL) -> tuple[int, str]:
       - ADVANTAGE: use d20.roll("2d20kh1") -- keep highest
       - DISADVANTAGE: use d20.roll("2d20kl1") -- keep lowest
       - NORMAL: use d20.roll("1d20")
       Return (total, str_representation). The str representation comes from d20 library's str(result).

    4. roll_damage(dice_expr: str) -> tuple[int, str]:
       - Use d20.roll(dice_expr) to roll damage dice
       - Return (total, str_representation)
       Example: roll_damage("2d6+3") -> (10, "2d6+3 (4+3+3)")

    Create tests/test_dice.py:

    - Test resolve_advantage with 0/0 sources -> NORMAL
    - Test resolve_advantage with 1 adv / 0 disadv -> ADVANTAGE
    - Test resolve_advantage with 0 adv / 1 disadv -> DISADVANTAGE
    - Test resolve_advantage with 1 adv / 1 disadv -> NORMAL (cancellation)
    - Test resolve_advantage with 3 adv / 1 disadv -> NORMAL (cancellation, NOT net advantage)
    - Test resolve_advantage with 2 adv / 5 disadv -> NORMAL (cancellation)
    - Test roll_d20 returns value between 1-20 for NORMAL
    - Test roll_d20 returns tuple (int, str)
    - Test roll_damage returns positive total for valid expression
    - Test roll_damage with "1d6+3" returns total between 4 and 9
    - Run 100 advantage rolls, verify all are 1-20 (no out-of-range)

    Run: `uv run pytest tests/test_dice.py -v`
  </action>
  <verify>
    uv run pytest tests/test_dice.py -v
    All tests pass. Advantage cancellation verified. Roll ranges correct.
  </verify>
  <done>
    AdvantageState ternary enum works. resolve_advantage correctly cancels ANY adv+disadv to NORMAL (not counter subtraction). roll_d20 and roll_damage produce valid results. Tests prove D&D 5e advantage rules.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rules engine -- attacks, damage, saves, death saves, healing</name>
  <files>
    src/domain/rules.py
    tests/test_rules.py
  </files>
  <action>
    Create src/domain/rules.py with these functions. All functions are pure (no side effects, no mutation). They take inputs and return results.

    1. AttackResult dataclass (frozen=True):
       - hit: bool
       - natural_roll: int
       - total_roll: int
       - is_critical: bool (natural 20)
       - is_fumble: bool (natural 1)
       - target_ac: int
       - description: str (human-readable like "d20(15) + 5 = 20 vs AC 18: HIT")

    2. make_attack_roll(attack_bonus: int, target_ac: int, advantage: AdvantageState = AdvantageState.NORMAL) -> AttackResult:
       - Roll d20 with advantage state using dice.roll_d20()
       - Natural 20 = always hit + critical
       - Natural 1 = always miss + fumble
       - Otherwise: (natural_roll + attack_bonus) >= target_ac
       - Build description string with roll details

    3. DamageResult dataclass (frozen=True):
       - raw_damage: int (before modifiers)
       - final_damage: int (after resistance/immunity/vulnerability)
       - damage_type: str
       - was_critical: bool
       - modifier_applied: str | None ("resistance", "immunity", "vulnerability", or None)
       - description: str

    4. roll_damage_for_attack(damage: DamageRoll, is_critical: bool = False) -> tuple[int, str]:
       - If critical: roll damage dice TWICE and sum (do NOT double the modifier, just roll the dice portion twice). For "1d8+3" on crit: roll 1d8 + 1d8 + 3. Use d20 library: parse the expression, double the dice portion.
       - Simpler approach for Phase 1: roll the full expression once, then roll JUST the dice portion again and add. Example: "1d6+3" on crit -> roll "1d6+3" + roll "1d6" extra.
       - Actually simplest correct approach: use d20.roll(dice_expr) for normal. For crit, double the dice count in the expression string (regex replace `(\d+)d` with `{int*2}d`). So "1d8+3" becomes "2d8+3", "2d6+2" becomes "4d6+2".
       - Return (total, description_string)

    5. apply_damage_modifiers(damage_amount: int, damage_type: str, creature: Creature) -> tuple[int, str | None]:
       Strict order per D&D 5e:
       a. Check immunity: if damage_type in creature.damage_immunities -> return (0, "immunity")
       b. Check resistance: if damage_type in creature.damage_resistances -> halve (floor division), return (halved, "resistance")
       c. Check vulnerability: if damage_type in creature.damage_vulnerabilities -> double, return (doubled, "vulnerability")
       d. Otherwise: return (damage_amount, None)
       Multiple instances of same type do NOT stack (set membership, not counting).
       Return (final_damage, modifier_name_or_none)

    6. apply_damage(creature: Creature, damage_amount: int, damage_type: str) -> tuple[Creature, DamageResult]:
       - Apply damage modifiers
       - Subtract from current_hp (can go below 0 for massive damage, but clamp at minimum -hp_max for instant death tracking)
       - Return (updated_creature via model_copy, DamageResult)

    7. SavingThrowResult dataclass (frozen=True):
       - success: bool
       - natural_roll: int
       - total_roll: int
       - dc: int
       - description: str

    8. make_saving_throw(creature: Creature, ability: str, dc: int, advantage: AdvantageState = AdvantageState.NORMAL) -> SavingThrowResult:
       - Roll d20 with advantage
       - Add ability modifier from creature.ability_scores.get_modifier(ability)
       - Total >= dc = success
       - Natural 20 always succeeds (not RAW for saves, but common house rule -- document this choice)
       - Return SavingThrowResult

    9. DeathSaveResult dataclass (frozen=True):
       - outcome: str ("success", "failure", "critical_success", "critical_failure", "stabilized", "dead")
       - natural_roll: int
       - new_death_saves: DeathSaves
       - regained_hp: int (1 if nat 20, else 0)
       - description: str

    10. make_death_save(creature: Creature) -> tuple[Creature, DeathSaveResult]:
        - Validate creature is at 0 HP and not stable
        - Roll 1d20:
          - Nat 1: 2 failures added
          - Nat 20: regain 1 HP, reset death saves
          - >= 10: 1 success
          - < 10: 1 failure
        - Check: 3+ successes -> stable=True
        - Check: 3+ failures -> outcome="dead"
        - Return (updated_creature, DeathSaveResult)

    11. apply_healing(creature: Creature, healing_amount: int) -> Creature:
        - Add healing to current_hp, cap at hp_max
        - If creature was at 0 HP with death saves, reset death saves
        - Return updated creature via model_copy

    Create tests/test_rules.py (comprehensive -- this is the core D&D mechanics):

    Attack tests:
    - Test make_attack_roll hit (mock roll to 15, bonus +5, AC 18 -> hit)
    - Test make_attack_roll miss (mock roll to 5, bonus +3, AC 18 -> miss)
    - Test natural 20 always hits regardless of AC
    - Test natural 1 always misses regardless of bonus
    - Test critical hit flag on natural 20

    Damage modifier tests (these are critical correctness tests):
    - Test immunity: 10 fire damage to fire-immune creature -> 0
    - Test resistance: 10 fire damage to fire-resistant creature -> 5
    - Test vulnerability: 10 fire damage to fire-vulnerable creature -> 20
    - Test no modifier: 10 slashing to creature with no modifiers -> 10
    - Test resistance rounds down: 7 fire to resistant -> 3 (floor)
    - Test immunity takes priority: creature immune AND resistant to fire, 10 fire -> 0
    - Test vulnerability AND resistance don't stack: creature both resistant and vulnerable to same type -> apply in order (resistance halves first to 5, then vulnerability doubles to 10 -- net neutral per RAW)

    Death save tests:
    - Test nat 1 adds 2 failures
    - Test nat 20 regains 1 HP and resets death saves
    - Test >= 10 adds 1 success
    - Test < 10 adds 1 failure
    - Test 3 successes -> stable
    - Test 3 failures -> dead

    Healing tests:
    - Test healing adds to current_hp
    - Test healing capped at hp_max
    - Test healing from 0 HP resets death saves

    Saving throw tests:
    - Test saving throw success (roll + modifier >= DC)
    - Test saving throw failure (roll + modifier < DC)

    Critical hit damage test:
    - Test roll_damage_for_attack doubles dice on crit

    For mocking d20 rolls: use unittest.mock.patch on dice.roll_d20 or d20.roll to control randomness. Alternatively, test with many runs and verify statistical properties.

    Preferred approach: patch `src.domain.dice.roll_d20` to return controlled values for deterministic tests. For damage, patch `d20.roll` directly.

    Run: `uv run pytest tests/test_rules.py -v`
  </action>
  <verify>
    uv run pytest tests/ -v
    All tests pass including dice AND rules. Specifically verify:
    - Advantage cancellation test passes (3 adv + 1 disadv = NORMAL)
    - Immunity/resistance/vulnerability ordering correct
    - Death save nat 1 = 2 failures, nat 20 = regain HP
    - Critical hit doubles dice
  </verify>
  <done>
    Rules engine implements all D&D 5e combat mechanics correctly. Attack rolls, damage with modifiers, saving throws, death saves, healing all work. 20+ tests verify correctness of edge cases (advantage cancellation, damage modifier order, death save nat 1/20). No stacking bugs.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -v` -- all tests pass (creature + distance + combat_state + markdown + dice + rules)
2. Verify advantage cancellation: test with multiple advantage sources + any disadvantage = NORMAL
3. Verify damage order: immunity checked before resistance, resistance before vulnerability
4. Verify death saves: nat 1 = 2 failures, nat 20 = 1 HP + reset, 3 successes = stable, 3 failures = dead
5. Verify crit damage: dice doubled (not total doubled)
</verification>

<success_criteria>
- AdvantageState ternary machine: any adv + any disadv = NORMAL (verified by test)
- Attack rolls: nat 20 always hits, nat 1 always misses, normal roll + bonus vs AC
- Damage modifiers apply in order: immunity -> resistance -> vulnerability (no stacking)
- Death saves track successes/failures separately with nat 1/20 special cases
- Saving throws: d20 + ability modifier vs DC
- Critical hits: damage dice doubled (not modifier)
- Healing: capped at hp_max, resets death saves at 0 HP
- 30+ total unit tests passing across all test files
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-combat/01-02-SUMMARY.md`
</output>

---
phase: 01-foundation-core-combat
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/agents/base.py
  - src/agents/heuristic.py
  - src/simulation/simulator.py
  - src/simulation/victory.py
  - src/io/logger.py
  - run.py
  - tests/test_heuristic.py
  - tests/test_simulator.py
  - tests/test_integration.py
autonomous: true

must_haves:
  truths:
    - "DM can run `python run.py --party data/creatures/fighter.md --enemies data/creatures/goblin.md` and see combat play out"
    - "Combat log shows initiative order, each creature's turn with attack rolls (hit/miss), damage dealt with type, and HP changes"
    - "Heuristic agent attacks nearest enemy with best available attack, moves toward target if out of range"
    - "Creatures with multiattack execute all attacks in a single action"
    - "Combat ends when one side has all members at 0 HP, and winner team is declared"
    - "Movement per turn is limited by creature speed (e.g., 30ft = 6 squares)"
    - "PCs at 0 HP make death saving throws each turn until stable or dead"
    - "Seeded runs produce deterministic output"
  artifacts:
    - path: "src/agents/base.py"
      provides: "BaseAgent protocol/ABC for all agent types"
      exports: ["BaseAgent", "AgentAction"]
    - path: "src/agents/heuristic.py"
      provides: "Greedy heuristic agent with target selection and attack choice"
      exports: ["HeuristicAgent"]
    - path: "src/simulation/simulator.py"
      provides: "Main combat loop: initiative -> turns -> victory"
      exports: ["run_combat"]
    - path: "src/simulation/victory.py"
      provides: "Victory condition detection"
      exports: ["is_combat_over", "get_winner"]
    - path: "src/io/logger.py"
      provides: "Combat event logging to structured output"
      exports: ["CombatLogger"]
    - path: "run.py"
      provides: "CLI entry point"
  key_links:
    - from: "src/simulation/simulator.py"
      to: "src/agents/base.py"
      via: "Simulator calls agent.choose_action each turn"
      pattern: "agent\\.choose_action"
    - from: "src/simulation/simulator.py"
      to: "src/domain/rules.py"
      via: "Simulator uses rules for attack/damage/save resolution"
      pattern: "make_attack_roll|apply_damage|make_death_save"
    - from: "src/simulation/simulator.py"
      to: "src/domain/combat_state.py"
      via: "Simulator reads/updates CombatState each turn"
      pattern: "CombatState|state\\."
    - from: "src/agents/heuristic.py"
      to: "src/domain/distance.py"
      via: "Agent uses distance for target selection and range checks"
      pattern: "distance_in_feet|manhattan_distance|move_toward"
    - from: "run.py"
      to: "src/io/markdown.py"
      via: "CLI loads creature files"
      pattern: "load_creature|load_creature_files"
    - from: "run.py"
      to: "src/simulation/simulator.py"
      via: "CLI runs combat simulation"
      pattern: "run_combat"
---

<objective>
Wire everything together: heuristic agent, combat simulator loop, victory detection, combat logger, and CLI entry point. After this plan, a DM can run a combat simulation from the terminal and see results.

Purpose: This is the capstone plan that turns isolated modules (models, grid, rules) into a working end-to-end combat simulator. The heuristic agent makes tactical decisions, the simulator orchestrates the turn loop, the logger produces readable combat output, and the CLI makes it all accessible.

Output: Working CLI that runs a combat simulation with heuristic agents, prints a combat log with dice rolls and results, and declares a winner.
</objective>

<execution_context>
@/Users/enrico/.claude/get-shit-done/workflows/execute-plan.md
@/Users/enrico/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-combat/01-RESEARCH.md
@.planning/phases/01-foundation-core-combat/01-01-SUMMARY.md
@.planning/phases/01-foundation-core-combat/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agent interface + Heuristic agent + Victory detection</name>
  <files>
    src/agents/base.py
    src/agents/heuristic.py
    src/simulation/victory.py
    tests/test_heuristic.py
  </files>
  <action>
    1. Create src/agents/base.py:

    AgentAction dataclass (frozen=True):
    - action_type: str  ("attack", "move", "move_and_attack", "dodge", "death_save", "healing")
    - attack_name: str | None = None  (which action to use, e.g., "Multiattack", "Longsword")
    - target_id: str | None = None  (creature_id of target)
    - move_to: str | None = None  (target position in chess notation)
    - description: str = ""  (human-readable summary for logging)

    BaseAgent (Protocol or ABC):
    - choose_action(state: CombatState, creature_id: str) -> AgentAction

    2. Create src/agents/heuristic.py with HeuristicAgent class:

    choose_action(state, creature_id) -> AgentAction:
    - Get creature from state
    - If creature is at 0 HP and not stable: return death_save action
    - If creature is at 0 HP and stable: skip (return dodge)
    - Get living enemies (different team, current_hp > 0)
    - If no enemies: return dodge
    - Select target: nearest enemy by Manhattan distance, ties broken by lowest current_hp (focus fire)
    - Choose best action: prefer Multiattack (is_multiattack=True) over single attacks. Among single attacks, pick highest expected damage (not implemented precisely in Phase 1 -- just pick first action with attacks).
    - Check range: calculate distance_in_feet between creature and target
      - For chosen attack, get range_feet from the first attack in the action's attacks list
      - If in range: return attack action
      - If out of range: calculate movement. Use move_toward() with creature.speed // 5 squares. After movement, re-check range. If now in range: return move_and_attack. If still out of range: return move (toward target).

    _get_enemies(state, creature) -> list of (creature_id, Creature) for enemies that are alive.

    _select_target(state, creature, enemies) -> tuple[str, Creature]: nearest by distance, then lowest HP.

    _choose_action_for_target(creature, target, distance_feet) -> Action: pick Multiattack if available, else first attack action that's in range.

    3. Create src/simulation/victory.py:

    - is_combat_over(state: CombatState) -> bool: Check if all creatures of any one team are at 0 HP (or dead via 3 death save failures). Return True if combat should end.

    - get_winner(state: CombatState) -> str | None: Return team name of the winning side (the team with at least one living member). Return None if draw (both sides eliminated somehow) or if combat is not over.

    Implementation: Group creatures by team. For each team, check if ALL members have current_hp <= 0 AND (death_saves.failures >= 3 OR death_saves.stable == False). Actually simpler: a team is eliminated if no member has current_hp > 0. A creature at 0 HP that is stable is still "down" -- their team loses if all members are at 0 HP (stable just means they won't die, but they can't fight).

    Even simpler for Phase 1: team is eliminated when ALL its members have current_hp <= 0. Winner is the team with at least one member with current_hp > 0.

    4. Create tests/test_heuristic.py:

    - Test agent selects nearest enemy as target
    - Test agent chooses multiattack over single attack when available
    - Test agent returns move action when target out of range
    - Test agent returns death_save when creature at 0 HP
    - Test agent returns dodge when no enemies remain
    - Use mock CombatState with 2-3 creatures for deterministic tests

    Run: `uv run pytest tests/test_heuristic.py -v`
  </action>
  <verify>
    uv run pytest tests/test_heuristic.py -v
    All tests pass. Agent selects targets, chooses attacks, handles movement and death saves.
  </verify>
  <done>
    Heuristic agent makes tactical decisions: targets nearest enemy, uses multiattack when available, moves toward targets out of range, handles death saves for downed creatures. Victory detection identifies eliminated teams.
  </done>
</task>

<task type="auto">
  <name>Task 2: Combat simulator loop + Logger + CLI entry point</name>
  <files>
    src/simulation/simulator.py
    src/io/logger.py
    run.py
    tests/test_simulator.py
    tests/test_integration.py
  </files>
  <action>
    1. Create src/io/logger.py:

    CombatLogger class:
    - __init__(self, verbose: bool = True): Store log entries as list of strings.
    - log_initiative(order: list[tuple[str, int]]): Log "=== Initiative Order ===" with each creature's roll.
    - log_round_start(round_num: int): Log "=== Round {N} ===" separator.
    - log_turn_start(creature_id: str, creature: Creature): Log "{name} (HP: {current}/{max}, Pos: {pos})" turn header.
    - log_movement(creature_id: str, from_pos: str, to_pos: str, distance: int): Log movement with distance.
    - log_attack(attacker: str, target: str, attack_name: str, attack_result: AttackResult): Log "Attack: {name} -> {target}: d20({nat}) + {bonus} = {total} vs AC {ac}: HIT/MISS"
    - log_damage(target: str, damage_result: DamageResult): Log "Damage: {amount} {type}{modifier_note}" with resistance/immunity/vulnerability notes.
    - log_hp_change(creature_id: str, old_hp: int, new_hp: int, max_hp: int): Log "HP: {old} -> {new}/{max}"
    - log_death_save(creature_id: str, result: DeathSaveResult): Log death save result with current tally.
    - log_combat_end(winner: str | None, rounds: int): Log "=== Combat Over ===" with winner and round count.
    - get_full_log() -> str: Join all entries with newlines.
    - print_log(): Print the full log to stdout.

    All log methods also print to stdout if verbose=True.

    2. Create src/simulation/simulator.py:

    run_combat(creatures: dict[str, Creature], agent: BaseAgent, seed: int | None = None, max_rounds: int = 100, verbose: bool = True) -> tuple[CombatState, CombatLogger]:

    The main loop:

    a. Roll initiative (using roll_initiative from combat_state module). If seed provided, pass it for determinism.
    b. Create initial CombatState with creatures and initiative_order.
    c. Create CombatLogger.
    d. Log initiative order.

    e. For each round (1 to max_rounds):
       - Log round start
       - For each creature_id in initiative_order:
         - Get creature from state. Skip if current_hp <= 0 AND death_saves.stable (stable, just skip). If current_hp <= 0 AND NOT stable AND death_saves.failures < 3: must make death save.
         - Log turn start.
         - Ask agent for action: action = agent.choose_action(state, creature_id)
         - Execute action based on action_type:

           "death_save":
             - Call rules.make_death_save(creature)
             - Update creature in state
             - Log death save result
             - If regained HP (nat 20): log HP change

           "move":
             - Move creature to action.move_to using distance.move_toward with speed limit
             - Update creature position in state
             - Log movement

           "attack":
             - Get the Action from creature.actions by attack_name
             - For each attack in the Action's attacks list (handles multiattack):
               - Call rules.make_attack_roll(attack.attack_bonus, target.ac, AdvantageState.NORMAL) -- Phase 1 uses NORMAL for all (no conditional advantage sources yet)
               - Log attack result
               - If hit: roll damage via rules.roll_damage_for_attack(attack.damage, is_critical=attack_result.is_critical)
               - Apply damage via rules.apply_damage(target_creature, raw_damage, damage_type)
               - Log damage and HP change
               - Update target creature in state
               - If target drops to 0 HP: log it

           "move_and_attack":
             - First do movement (same as "move" above)
             - Then do attack (same as "attack" above)

           "dodge":
             - Log "takes Dodge action" (no mechanical effect in Phase 1)

         - After each creature's turn: check is_combat_over(state). If yes, break.
       - After round: check is_combat_over(state). If yes, break.

    f. Determine winner via get_winner(state).
    g. Log combat end.
    h. Return (final_state with is_over and winner set, logger).

    Important implementation notes:
    - State is immutable. Each update creates new state via CombatState methods (update_creature, add_log, etc.) or dataclasses.replace.
    - Creature updates use creature.model_copy(update={...}).
    - Track movement budget per turn: creature gets speed // 5 squares per turn. Reset at start of each creature's turn.
    - Death saves: creatures at 0 HP that are NOT stable and NOT dead (failures < 3) must make death saves on their turn. The agent should return "death_save" for these creatures, but the simulator should also enforce it (if agent returns something else for a 0 HP creature, override with death save).

    3. Create run.py (CLI entry point):

    Use argparse with these arguments:
    - --party: list of .md file paths (nargs="+", required)
    - --enemies: list of .md file paths (nargs="+", required)
    - --seed: optional int for deterministic runs
    - --max-rounds: int, default 100
    - --quiet: flag to suppress verbose output (just show final result)
    - --agent: str, default "heuristic" (only option in Phase 1)

    Flow:
    a. Parse args
    b. Load party creatures from --party files using load_creature_files
    c. Load enemy creatures from --enemies files using load_creature_files
    d. Merge into single creatures dict
    e. Handle duplicate creature_ids by appending numbers (goblin -> goblin, goblin-2, etc.)
    f. Create HeuristicAgent
    g. Call run_combat(creatures, agent, seed, max_rounds, verbose=not args.quiet)
    h. Print final summary: winner, rounds, surviving creatures with HP

    4. Create tests/test_simulator.py:

    - Test run_combat runs to completion (does not hang or error)
    - Test combat ends when one side eliminated
    - Test seeded combat produces same result twice
    - Test max_rounds limit is respected
    - Use simple 1v1 creature setup (fighter vs goblin from sample data)

    5. Create tests/test_integration.py:

    Full end-to-end integration test:
    - Load fighter.md and goblin.md from data/creatures/
    - Run combat with HeuristicAgent and a fixed seed
    - Verify combat finishes (is_over=True)
    - Verify winner is declared (not None)
    - Verify combat log contains expected entries (initiative, at least 1 attack, combat end)
    - Verify running same seed twice produces identical results

    Run: `uv run pytest tests/ -v`
  </action>
  <verify>
    1. `uv run pytest tests/ -v` -- all tests pass (50+ tests across all files)
    2. `uv run python run.py --party data/creatures/fighter.md --enemies data/creatures/goblin.md --seed 42` -- produces combat log output and declares a winner
    3. Run the above command twice with same seed -- output is identical (deterministic)
    4. `uv run python run.py --party data/creatures/fighter.md --enemies data/creatures/goblin.md` -- runs without seed (random), completes and shows result
  </verify>
  <done>
    Full combat simulation runs end-to-end. `python run.py --party fighter.md --enemies goblin.md --seed 42` produces combat log with initiative, attack rolls (hit/miss), damage with types, HP changes, and declares winner. Seeded runs are deterministic. Heuristic agent makes tactical decisions. All Phase 1 requirements verified working.
  </done>
</task>

</tasks>

<verification>
1. `uv run pytest tests/ -v` -- all tests pass (50+ tests)
2. `uv run python run.py --party data/creatures/fighter.md --enemies data/creatures/goblin.md --seed 42` -- shows full combat log
3. Verify log contains: initiative order, attack rolls with d20 natural + bonus vs AC, damage with type, HP tracking, combat end with winner
4. Run with --seed 42 twice: identical output (deterministic)
5. Run without --seed: combat completes (no hang), result varies between runs
6. Create a creature with damage_resistances: ["fire"], attack with fire damage, verify "resistance" appears in log and damage is halved
</verification>

<success_criteria>
- `python run.py --party ... --enemies ...` runs a complete combat simulation
- Combat log shows: initiative rolls, turn-by-turn actions, attack rolls (d20 + bonus vs AC: HIT/MISS), damage (amount type), HP changes (old -> new/max), death saves (if applicable), combat end with winner
- Heuristic agent: targets nearest enemy, uses multiattack, moves toward targets out of range
- Movement limited by speed per turn (30ft = 6 squares)
- Seeded runs produce identical output
- Victory detected when all members of one team are at 0 HP
- 50+ unit tests passing across all test files
- Integration test proves end-to-end correctness
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-combat/01-03-SUMMARY.md`
</output>

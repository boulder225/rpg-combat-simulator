---
phase: 04-terminal-ui-advanced-combat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/terrain.py
  - src/domain/cover.py
  - src/io/terrain_loader.py
  - tests/test_terrain.py
  - tests/test_cover.py
autonomous: true

must_haves:
  truths:
    - "Terrain is defined in .md files with YAML frontmatter (name, cover_zones)"
    - "Cover zone has cells (list) or from/to rectangle and type (half | three-quarters)"
    - "get_cover(attacker_pos, target_pos, terrain) returns none | half | three-quarters using line/ray through grid"
    - "No terrain (open field) returns none for all positions"
  artifacts:
    - path: "src/domain/terrain.py"
      provides: "Terrain and CoverZone Pydantic models"
      exports: ["Terrain", "CoverZone"]
    - path: "src/domain/cover.py"
      provides: "Cover calculation from positions and terrain"
      exports: ["get_cover"]
    - path: "src/io/terrain_loader.py"
      provides: "Load terrain from data/terrain/*.md or data/arenas/*.md"
      exports: ["load_terrain", "TerrainLoader"]
    - path: "tests/test_terrain.py"
      provides: "Terrain model and loader tests"
    - path: "tests/test_cover.py"
      provides: "get_cover tests (no cover, half, three-quarters, ray through zone)"
  key_links:
    - from: "src/domain/cover.py"
      to: "src/domain/distance.py"
      via: "parse_coordinate for ray stepping"
      pattern: "parse_coordinate|manhattan"
    - from: "src/io/terrain_loader.py"
      to: "src/domain/terrain.py"
      via: "Terrain model validation"
      pattern: "Terrain\\.model_validate|Terrain\\(\\*\\*"
---

<objective>
Implement terrain model and cover calculation so combat can later apply +2/+5 AC and DEX save bonuses.

Purpose: Phase 4 success criteria require half-cover (+2 AC, +2 DEX saves) and three-quarters cover (+5). Terrain is defined in .md files; cover is computed from attacker position, target position, and terrain cover zones (ray from attacker to target; if ray passes through a cover zone, target has that cover type).

Output: Terrain and CoverZone models, terrain loader from markdown, get_cover(attacker_pos, target_pos, terrain) returning "none" | "half" | "three-quarters", with tests. No simulator or rules changes yet.
</objective>

<execution_context>
@.planning/phases/04-terminal-ui-advanced-combat/04-CONTEXT.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-terminal-ui-advanced-combat/04-CONTEXT.md
@src/domain/distance.py
@src/domain/creature.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Terrain and CoverZone domain models</name>
  <files>src/domain/terrain.py</files>
  <action>
Create src/domain/terrain.py with:
- CoverZone: type Literal["half", "three-quarters"], cells list[str] (chess notation) OR from/to rectangle (e.g. from: "B2", to: "C4"). Normalize to a set of cells for querying.
- Terrain: name (str), cover_zones (list[CoverZone]). Method or helper to get all blocking cells.
- Use Pydantic v2. No I/O in this file.
  </action>
  <verify>python -c "from src.domain.terrain import Terrain, CoverZone; z = CoverZone(type='half', cells=['B2','B3']); t = Terrain(name='arena', cover_zones=[z]); print(t.name)"</verify>
  <done>Terrain and CoverZone models exist and validate</done>
</task>

<task type="auto">
  <name>Task 2: get_cover(attacker_pos, target_pos, terrain)</name>
  <files>src/domain/cover.py</files>
  <action>
Create src/domain/cover.py with:
- get_cover(attacker_pos: str, target_pos: str, terrain: Terrain | None) -> Literal["none", "half", "three-quarters"].
- If terrain is None or has no cover zones, return "none".
- Else: compute cells on the line from attacker to target (Bresenham-like or step along Manhattan path). For each cell on the path (excluding attacker and target), if it is in a cover zone, the target has at least that cover. Use the strongest cover type (three-quarters > half).
- Use parse_coordinate from distance.py. Handle edge case: attacker == target -> "none".
  </action>
  <verify>Tests: no terrain -> none; ray through half zone -> half; ray through three-quarters -> three-quarters; ray through both -> three-quarters</verify>
  <done>get_cover returns correct type for test cases</done>
</task>

<task type="auto">
  <name>Task 3: Load terrain from markdown</name>
  <files>src/io/terrain_loader.py</files>
  <action>
Create terrain loader:
- Load from data/terrain/ or data/arenas/ (configurable). One .md file per terrain (e.g. warehouse.md).
- YAML frontmatter: name, cover_zones list. Each zone: type: half | three-quarters, cells: ["B2","B3"] or from: "B2", to: "C4".
- If body content exists, ignore or store as description (optional). Return Terrain instance.
- TerrainLoader class with load(name: str) -> Terrain, or load_terrain(path: Path) -> Terrain. Create data/terrain/.gitkeep if dir missing.
  </action>
  <verify>Load a sample terrain .md file and assert terrain.name and cover_zones populated</verify>
  <done>Terrain loads from markdown; tests use a fixture .md</done>
</task>

<task type="auto">
  <name>Task 4: Tests for terrain and cover</name>
  <files>tests/test_terrain.py, tests/test_cover.py</files>
  <action>
- test_terrain.py: Terrain/CoverZone creation, rectangle expansion to cell set, loader with fixture.
- test_cover.py: get_cover with no terrain; open field; one half zone between A1 and C3 (path crosses zone -> half); three-quarters zone; zone on target cell (optional: treat as cover or not per 5e).
  </action>
  <verify>uv run pytest tests/test_terrain.py tests/test_cover.py -v</verify>
  <done>All new tests pass</done>
</task>
</tasks>

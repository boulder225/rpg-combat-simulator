---
phase: 04-terminal-ui-advanced-combat
plan: 02
type: execute
wave: 1
depends_on: [04-01]
files_modified:
  - src/domain/rules.py
  - src/simulation/simulator.py
  - src/cli/batch_args.py
  - run.py
autonomous: true

must_haves:
  truths:
    - "When resolving attack roll, target's effective AC = AC + cover bonus (0, +2, or +5)"
    - "When resolving DEX save, DC or save modifier includes cover (+2 or +5 to the save)"
    - "run_combat accepts optional terrain; if provided, cover is applied"
    - "CLI accepts --terrain NAME; loads terrain and passes to combat"
  artifacts:
    - path: "src/domain/rules.py"
      provides: "make_attack_roll and save resolution accept optional cover_bonus"
    - path: "src/simulation/simulator.py"
      provides: "run_combat(..., terrain=None); calls get_cover and passes bonus to rules"
    - path: "run.py"
      provides: "Parse --terrain; load terrain when present; pass to single and batch run"
  key_links:
    - from: "src/simulation/simulator.py"
      to: "src/domain/cover.py"
      via: "get_cover before attack/save"
      pattern: "get_cover"
    - from: "src/domain/rules.py"
      to: "attack roll"
      via: "effective AC = ac + cover_bonus"
      pattern: "ac \\+ |cover"
---

<objective>
Wire cover into combat resolution so that attacks and DEX saves apply +2 (half) or +5 (three-quarters) when the target has cover.

Purpose: Success criterion 4 requires "Creature behind half-cover gets +2 AC and DEX saves, three-quarters cover gets +5". Plan 04-01 provides get_cover; this plan uses it in the simulator and rules layer.

Output: Rules layer accepts optional cover bonus; simulator computes cover when terrain is present and passes it to attack/save resolution; CLI --terrain loads terrain and passes it through. No new UI or opportunity attacks yet.
</objective>

<execution_context>
@.planning/phases/04-terminal-ui-advanced-combat/04-CONTEXT.md
</execution_context>

<context>
@.planning/phases/04-terminal-ui-advanced-combat/04-CONTEXT.md
@src/domain/rules.py
@src/domain/cover.py
@src/simulation/simulator.py
@src/io/terrain_loader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rules layer accepts cover bonus</name>
  <files>src/domain/rules.py</files>
  <action>
- make_attack_roll(bonus, ac, advantage=None, cover_bonus=0): effective_ac = ac + cover_bonus. Use effective_ac for hit determination. Existing callers pass cover_bonus=0 or omit for backward compatibility.
- If there is a DEX save helper, add cover_bonus to the save (e.g. add to DC or to the save roll per 5e: cover adds to the save result). Document: half +2, three-quarters +5 to the saving throw result.
  </action>
  <verify>Unit test: make_attack_roll with cover_bonus=2 increases effective AC by 2</verify>
  <done>Rules use cover_bonus in attack and save resolution</done>
</task>

<task type="auto">
  <name>Task 2: Simulator uses terrain and get_cover</name>
  <files>src/simulation/simulator.py</files>
  <action>
- run_combat(creatures, agent, seed=..., max_rounds=..., verbose=..., terrain=None).
- Before each attack roll: if terrain, cover = get_cover(attacker.position, target.position, terrain); cover_bonus = 0 if none else 2 if half else 5; pass cover_bonus to make_attack_roll.
- If any DEX saves are resolved in simulator (e.g. for future AoE), apply same cover to save. For now only attack roll integration is required.
  </action>
  <verify>Integration test or manual: run combat with terrain that has cover between two positions; confirm AC is effectively higher for covered target</verify>
  <done>Simulator passes terrain and cover into rules</done>
</task>

<task type="auto">
  <name>Task 3: CLI --terrain and pass-through</name>
  <files>src/cli/batch_args.py, run.py</files>
  <action>
- Add --terrain optional argument (default None). When set, load terrain by name from data/terrain/ (or arenas) using TerrainLoader/load_terrain.
- In run_single_combat and run_batch_simulation, pass terrain into run_combat / batch runner. Batch runner must pass terrain to each run_combat call.
  </action>
  <verify>python run.py --party fighter.md --enemies goblin --terrain arena (with arena.md present) runs without error and terrain is used</verify>
  <done>--terrain loads terrain and is passed to combat</done>
</task>
</tasks>

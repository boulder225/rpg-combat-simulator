---
phase: 04-terminal-ui-advanced-combat
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/domain/combat_state.py
  - src/simulation/simulator.py
  - src/io/logger.py
autonomous: true

must_haves:
  truths:
    - "When a creature moves from a cell within an enemy's melee reach to a cell outside, that enemy may make one opportunity attack (reaction)"
    - "Reaction is consumed for the round; one opportunity attack per eligible creature per triggering move"
    - "Opportunity attack is a single melee attack using the attacker's first melee action or designated reaction attack"
    - "Reach is from stat block (default 5 ft = 1 square); distance = Manhattan * 5"
  artifacts:
    - path: "src/domain/combat_state.py"
      provides: "Per-round reaction tracking (reaction_used set or dict by creature_id)"
    - path: "src/simulation/simulator.py"
      provides: "On movement: detect leave-reach, resolve opportunity attacks, then complete move"
    - path: "src/io/logger.py"
      provides: "Log opportunity attack events"
  key_links:
    - from: "src/simulation/simulator.py"
      to: "src/domain/distance.py"
      via: "distance_in_feet for reach check"
      pattern: "distance_in_feet|manhattan"
---

<objective>
Implement opportunity attacks: when a creature leaves another creature's melee reach during movement, the creature whose reach is left may use its reaction to make one melee attack.

Purpose: Success criterion 5 requires "Creature leaving melee reach triggers opportunity attack". Phase 4 uses terrain-only cover (no creature-as-cover); one reaction per creature per round; no other reaction types yet.

Output: Combat state or simulator tracks reactions_used per round; on position update (move or move_and_attack), before applying new position, check if any enemy has current cell in reach and new cell out of reach; for each such enemy, if reaction not used, resolve one melee attack (first melee attack from stat block), then mark reaction used; then apply movement. Log opportunity attacks.
</objective>

<execution_context>
@.planning/phases/04-terminal-ui-advanced-combat/04-CONTEXT.md
</execution_context>

<context>
@.planning/phases/04-terminal-ui-advanced-combat/04-CONTEXT.md
@src/domain/combat_state.py
@src/simulation/simulator.py
@src/domain/rules.py
@src/domain/creature.py
@src/domain/distance.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Track reactions per round</name>
  <files>src/domain/combat_state.py</files>
  <action>
- Add reaction_used: set[str] (creature_ids) or dict[str, bool] to CombatState. Reset at start of each round (increment round or in round loop).
- Immutable update: when marking reaction used, return new state with updated set/dict. Ensure round advancement resets reaction_used for new round.
  </action>
  <verify>CombatState can hold and update reaction_used; new round resets it</verify>
  <done>Reaction tracking on state; reset each round</done>
</task>

<task type="auto">
  <name>Task 2: Resolve opportunity attack on leave-reach</name>
  <files>src/simulation/simulator.py</files>
  <action>
- When processing move or move_and_attack: (1) current position = c.position, new position = action.move_to. (2) For each enemy (different team, alive): if enemy has reaction_used skip. Else compute reach (enemy's melee reach from first melee action or 5 ft). If distance_in_feet(current, enemy.position) <= reach and distance_in_feet(new_position, enemy.position) > reach: enemy triggers opportunity attack. (3) For each such enemy: resolve one melee attack (enemy -> moving creature), apply damage, log, update state (target HP, reaction_used for enemy). (4) Then apply moving creature's position update and continue (attack action if move_and_attack).
- Use _find_action to get melee attack; use first attack from first melee action. If no melee action, skip opportunity attack for that creature.
  </action>
  <verify>Test: creature A moves from adjacent to B to 2 squares away; B gets one opportunity attack; B's reaction_used; second move in same round by another creature does not give B another attack</verify>
  <done>Opportunity attacks resolve and are logged</done>
</task>

<task type="auto">
  <name>Task 3: Log opportunity attacks</name>
  <files>src/io/logger.py</files>
  <action>
- Add log_opportunity_attack(attacker_name, target_name, attack_name, result) or similar. Call from simulator when opportunity attack is resolved.
  </action>
  <verify>Combat log shows opportunity attack when it occurs</verify>
  <done>Opportunity attacks appear in log</done>
</task>
</tasks>
